　


# 一、Linux操作系统介绍

## 1、Linux简介

Linux是基于Linux的操作系统是20世纪1991年推出的一个多用户、多任务的操作系统。它与UNIX完全兼容。Linux最初是由芬兰赫尔辛基大学计算机系学生Linus Torvalds在基于UNIX的基础上开发的一个操作系统的内核程序,Linux的设计是为了在Intel微处理器上更有效的运用。其后在理查德·斯托曼的建议下以GNU通用公共许可证发布，成为自由软件Unix变种。它的最大的特点在于他是一个源代码公开的自由及开放源码的操作系统，其内核源代码可以自由传播。
 
准确的说，Linux应该是符合UNIX规范的一个操作系统，Linix是基于源代码的方式进行开发的。Linux是一套免费使用和自由传播的类似UNIX的操作系统，这个系统是由全世界各地的成千上万的程序员设计和实现的。用户不用支付任何费用就可以获得它和它的源代码，并且可以根据自己的需要对它进行必要的修改，无偿对它使用，无约束地继续传播。

Linux以它的高效性和灵活性著称。它能够在PC计算机上实现全部的UNIX特性，具有多任务、多用户的能力。而且还包括了文本编辑器、高级语言编译器等应用软件。它还包括带有多个窗口管理器的X—Windows图形用户界面，如同我们使用Windows NT一样，允许我们使用窗口、图标和菜单对系统进行操作。它是一个功能强大、性能出众、稳定可靠的操作系统。

## 2.主要的Linux版本




由于众多发行版百花齐放，Linux的阵营日益壮大，每一款发行版都拥有一大批用户，开发者自愿为相关项目投入精力。Linux发行版可谓是形形色色，它们旨在满足每一种能想得到的需求。
![](./assets/linux_2.png)

###  Debian

Debian运行起来极其稳定，这使得它非常适合用于服务器。Debian平时维护三套正式的软件库和一套非免费软件库，这给另外几款发行版（比如Ubuntu和Kali等）带来了灵感。Debian这款操作系统派生出了多个Linux发行版。它有37500多个软件包，这方面唯一胜过Debian的其他发行版只有Gentoo。Debian使用apt或aptitude来安装和更新软件。

Debian这款操作系统无疑并不适合新手用户，而是适合系统管理员和高级用户。Debian支持如今的大多数架构（处理器）。

下载Debian ISO映像文件：http://dd.ma/BnNdplbF

### Gentoo

与Debian一样，Gentoo这款操作系统也包含数量众多的软件包。Gentoo并非以预编译的形式出现，而是每次需要针对每个系统进行编译。连Gentoo社区都觉得Gentoo安装和使用起来很困难；不过它被认为是最佳学习对象，可以进而了解Linux操作系统的内部运作原理。提到Gentoo总有人这么说："如果你要学用Linux发行版，那就学用该发行版吧；如果你学会了Gentoo，也就学会了Linux。"Gentoo使用portage来安装和更新软件。

Gentoo这款操作系统适合对Linux已经完全驾轻就熟的那些用户。

下载和安装Gentoo：http://dd.ma/Y0dT3sAQ

### Ubuntu

Ubuntu是Debian的一款衍生版，也是当今最受欢迎的免费操作系统。Ubuntu侧重于它在这个市场的应用，在服务器、云计算、甚至一些运行Ubuntu Linux的移动设备上很常见。作为Debian Gnu Linux的一款衍生版，Ubuntu的进程、外观和感觉大多数仍然与Debian一样。它使用apt软件管理工具来安装和更新软件。它也是如今市面上用起来最容易的发行版之一。Ubuntu使用基于apt的程序包管理器。

Ubuntu是新手用户肯定爱不释手的一款操作系统。

下载Ubuntu ISO映像文件：http://dd.ma/8ek7k9OR

### Damn Vulnerable Linux

当然，大多数人可能对这款发行版前所未闻，不过该发行版在本文中还是占有一席之地。那么，它有何过人之处呢？ Damn Vulnerable Linux恰如其名：其字面意思就是"该死的易受攻击的Linux"。Vulnerable Linux（DVL）根本不是一般意义上的优秀的Linux发行版。它有意捆绑了坏的、配置不当的、过时的、很容易被不法分子攻击的软件。

它的目的在于借机训练Linux管理员。还有什么比给Linux管理员一款坏的发行版去排解问题来得更管用的吗？面对Apache、MySQL、PHP、FTP和SSH等比较旧或破的版本，接受训练的管理员够有得忙了。

Damn Vulnerable Linux堪称旨在训练管理员的实验室。

下载Damn Vulnerable Linux（DVL）ISO映像文件：DVL_1.5_Infectious_Disease.iso

### 红帽企业级Linux

这是第一款面向商业市场的Linux发行版。它有服务器版本，支持众多处理器架构，包括x86和x86_64。红帽公司通过课程红帽认证系统管理员/红帽认证工程师（RHCSA/RHCE），对系统管理员进行培训和认证。就全球市场而言，总利润中80%来自支持，另外20%来自培训和认证，不过在印度不是这样。

在印度，红帽的利润中80%来自认证和培训，只有20%来自支持。而Fedora是个平台，而不是开发新产品或新应用程序的测试环境；一旦成为稳定版，就与红帽企业级Linux捆绑在一起，包括支持。红帽提供了非常多的稳定版应用程序，但是众所周知的缺点是，把太多旧程序包打包起来，支持成本确实相当高。不过，如果安全是关注的首要问题，那么红帽企业级Linux的确是款完美的发行版，它使用YUM程序包管理器。

红帽企业级Linux是系统管理员的第一选择，它有众多的程序包，还有非常到位的支持。

由于该发行版是商业化产品，所以不是免费的。不过，你可以下载用于教学用途的测试版。

下载红帽企业级Linux测试版DVD ISO映像文件：RedHat Enterprise Linux（测试版）

### CentOS

CentOS是一款企业级Linux发行版，它使用红帽企业级Linux中的免费源代码重新构建而成。这款重构版完全去掉了注册商标以及Binary程序包方面一个非常细微的变化。有些人不想支付一大笔钱，又能领略红帽企业级Linux；对他们来说，CentOS值得一试。此外，CentOS的外观和行为似乎与母发行版红帽企业级Linux如出一辙。 CentOS使用YUM来管理软件包。

非常稳定的程序包；谁要是想在桌面端测试一下服务器的运作原理，都应该试试这款操作系统。

下载CentOS 6.4 DVD ISO映像文件：http://dd.ma/BNbpqFB8

### Fedora

小巧的Fedora适合那些人：想尝试最先进的技术，等不及程序的稳定版出来。其实，Fedora就是红帽公司的一个测试平台；产品在成为企业级发行版之前，在该平台上进行开发和测试。Fedora是一款非常好的发行版，有庞大的用户论坛，软件库中还有为数不少的软件包。Fedora同样使用YUM来管理软件包。

下载Fedora 18（Spherical Cow）DVD ISO映像文件：http://dd.ma/CyBshk4Q

### Kali Linux

Kali Linux是Debian的一款衍生版。Kali旨在用于渗透测试。它大概在三个月前才发行。Kali的前身是Backtrack。用于Debian的所有Binary软件包都可以安装到Kali Linux上，而Kali的魅力或威力就来自于此。此外，支持Debian的用户论坛为Kali加分不少。Kali随带许多的渗透测试工具，无论是Wifi、数据库还是其他任何工具，都设计成立马可以使用。Kali使用APT来管理软件包。

毫无疑问，Kali Linux是一款渗透测试工具，或者是文明黑客（我不想谈论恶意黑客）青睐的操作系统。

下载Kali Linux DVD ISO映像文件：Kali Linux 6

### Arch Linux

Arch是一款采用滚动发行方式的操作系统：只要安装一次就够了；每当发行了某个新版本，就可以升级发行版，不需要重新安装。Pacman是Arch Linux的软件包管理器。Arch Linux既支持X86处理器架构，又支持X86_64架构，安装程序可以从光盘或U盘来运行。Arch旨在从开发者的角度而不是从用户的角度做到力求简单。Arch配置和安装起来超容易。它真是一款面向高手的发行版，让你可以了解Linux系统的每一个细枝末节。

下载Arch Linux ISO映像文件：http://dd.ma/kIkgJGD1

### OpenSuse

OpenSuse这款Linux发行版是免费的，并不供商业用途使用，仍然供个人使用。OpenSuse的真正竞争对手是红帽企业级Linux。它使用Yast来管理软件包。有了Yast，使用和管理服务器应用程序就非常容易。此外，Yast安装向导程序可以配置电子邮件服务器、LDAP服务器、文件服务器或Web服务器，没有任何不必要的麻烦。它随带snapper快照管理工具，因而可以恢复或使用旧版的文件、更新和配置。由于让滚动发行版本成为可能的Tumbleweed，可将已安装的操作系统更新到最新版本，不需要任何的新发行版。

SUSE在管理员当中的名气更大，因为它有Yast以及让系统管理员能够自动管理任务的其他此类应用程序，同样水准的其他发行版没有这项功能。

下载OpenSuse 12.3 DVD ISO映像文件：http://dd.ma/gSerotMi

# 二、开机和关机

## 1、Linux开机流程：

- 1、加载BIOS的硬件信息，获得第一个开机装置的代号。

- 2、读取第一个开机装置的MBR的boot loader（Lilo或者grub等）的开机信息。

- 3、加载kernel操作系统核心信息，kernel开始解压缩，并尝试驱动所有硬件装置。

- 4、kernel执行init程序并取得run—level的信息。

- 5、init执行/etc/rc.d/rc.sysinit文件。

- 6、启动核心的外挂模块（/etc/modprobe.conf）

- 7、init执行run-level的各个批次文件（Scripts）

- 8、init执行/etc/rc.d/rc.local文件。

- 9、执行/bin/login程序，并等待使用者登入。

- 10、登入之后开始以shell控管主机。

## 2、Linux关机命令：

我们可以使用以下三种命令来关机 Linux ：

* shutdown

Linux shutdown 命令可以用来进行关机程序，并且在关机以前传送讯息给所有使用者正在执行的程序，shutdown 也可以用来重开机。

语法：

```
shutdown [-t seconds] [-rkhncfF] time [message]

```
参数说明：

```
-t seconds : 设定在几秒钟之后进行关机程序。

-k : 并不会真的关机，只是将警告讯息传送给所有使用者。

-r : 关机后重新开机。

-h : 关机后停机。

-n : 不采用正常程序来关机，用强迫的方式杀掉所有执行中的程序后自行关机。

-c : 取消目前已经进行中的关机动作。

-f : 关机时，不做 fsck 动作(检查 Linux 档系统)。

-F : 关机时，强迫进行 fsck 动作。

time : 设定关机的时间。

message : 传送给所有使用者的警告讯息。

```
e.g:

```
立即关机
# shutdown -h now


指定 10 分钟后关机
# shutdown -h 10


重新启动计算机
# shutdown -r now

```

* halt

语法

```
halt [-n] [-w] [-d] [-f] [-i] [-p]
```

参数说明：

```
-n : 在关机前不做将记忆体资料写回硬盘的动作
-w : 并不会真的关机，只是把记录写到 /var/log/wtmp 文件里
-d : 不把记录写到 /var/log/wtmp 文件里（-n 这个参数包含了 -d） -f : 强迫关机，不呼叫 shutdown 这个指令
-i : 在关机之前先把所有网络相关的装置先停止
-p : 当关机的时候，顺便做关闭电源（poweroff）的动作
```
实例

```
关闭系统
# halt

关闭系统并关闭电源
# halt -p


关闭系统，但不留下纪录
# halt -d

```


* poweroff

poweroff 命令命令用于关闭计算器并切断电源。

语法

```
poweroff [-n] [-w] [-d] [-f] [-i] [-h]
```

参数说明：

```
-n : 在关机前不做将记忆体资料写回硬盘的动作
-w : 并不会真的关机，只是把记录写到 /var/log/wtmp 档案里
-d : 不把记录写到 /var/log/wtmp 文件里
-i : 在关机之前先把所有网络相关的装置先停止
-p : 关闭操作系统之前将系统中所有的硬件设置为备用模式。
```

实例

```
关闭系统
# poweroff
```

## 3、Linux重启命令

Linux reboot命令用于用来重新启动计算机。



语法

```
reboot [-n] [-w] [-d] [-f] [-i]
```


参数：
```
-n : 在重开机前不做将记忆体资料写回硬盘的动作
-w : 并不会真的重开机，只是把记录写到 /var/log/wtmp 档案里
-d : 不把记录写到 /var/log/wtmp 档案里（-n 这个参数包含了 -d）
-f : 强迫重开机，不呼叫 shutdown 这个指令
-i : 在重开机之前先把所有网络相关的装置先停止
```

实例

```
重新启动
# reboot
```

# 三、shell介绍

## 1、shell

shell是外壳的意思，就是操作系统的外壳。。总结来说，Shell是一个命令解释器，它通过接受用户输入的Shell命令来启动、暂停、停止程序的运行或对计算机进行控制。

shell 是一个应用程序，它连接了用户和 Linux 内核，让用户能够更加高效、安全、低成本地使用 Linux 内核，这就是 Shell 的本质。

shell 本身并不是内核的一部分，它只是站在内核的基础上编写的一个应用程序。

## 2、shell命令 

我们可以通过shell命令来操作和控制操作系统，比如Linux中的Shell命令就包括ls、cd、pwd等等

## 3、shell脚本

shell脚本就是由Shell命令组成的执行文件，将一些命令整合到一个文件中，进行处理业务逻辑，脚本不用编译即可运行。它通过解释器解释运行，所以速度相对来说比较慢。

shell脚本中最重要的就是对shell命令的使用与组合，再使用shell脚本支持的一些语言特性，完成想要的功能。


## 4、shell仿真器和基本操作

Linux系统启动后，会启动终端仿真器，仿真器启动成功后，屏幕上会显示提示符：

```
[me@linuxbox ~]$
```
它表明shell 准备好了去接受输入。

提示符通常包括你的用户名@主机名，紧接着当前工作目录和一个美元符号。

如果提示符的最后一个字符是“#”, 而不是“$”, 那么这个终端会话就有超级用户权限。 这意味着，我们或者是
以 root 用户的身份登录，或者是我们选择的终端仿真器提供超级用户（管理员）权限。

## 5、如何结束当前会话终端：

我们可以通过关闭终端仿真器窗口，或者是在 shell 提示符下输入 exit 命令来终止一个终端会话：

```
[me@linuxbox ~]$ exit

```

# 四、命令介绍


## 1、Linux命令

命令可以是下面四种形式之一：

1. 是一个可执行程序，就像我们所看到的位于目录/usr/bin 中的文件一样。 属于这一类的程序，可以编译成二进制文件，诸如用 C 和 C++语言写成的程序, 也可以是由脚本语言写成的程序，比如说 shell，perl，python，ruby，等等。


2. 是一个内建于 shell 自身的命令。bash 支持若干命令，内部叫做 shell 内部命令 (builtins)。例如，cd 命令，就是一个 shell 内部命令。


3. 是一个 shell 函数。这些是小规模的 shell 脚本，它们混合到环境变量中。 在后续的章节里，我们将讨论配置环境变量以及书写 shell 函数。但是现在， 仅仅意识到它们的存在就可以了。


4. 是一个命令别名。我们可以定义自己的命令，建立在其它命令之上。

所以大多数命令看起来像这样：


## 2、Linux命令格式

大多数命令名经常会带有一个或多个用来更正命令行为的选项， 更进一步，选项后面会带有一个或多个参数，这些参数是命令作用的对象。

```
command -options arguments
```

大多数命令使用的选项，是由一个中划线加上一个字符组成，例如，“-l”，但是许多命令，包括来自于 GNU项目的命令，也支持长选项，长选项由两个中划线加上一个字组成。当然，许多命令也允许把多个短选项串在一起使用。下面这个例子，ls 命令有两个选项， “l” 选项产生长格式输出，“t”选项按文件修改时间的先后来排序。

## 3、Linux命令相关的shell命令

### type  --显示命令的类别

type 命令是 shell 内部命令，它会显示命令的类别，给出一个特定的命令名（做为参数）。 它像这样工作：
```
type command
```
"command"是你要检测的命令名

用法：
```
[me@linuxbox ~]$ type type
type is a shell builtins

[me@linuxbox ~]$ type ls
ls is aliased to `ls --color=tty`

[me@linuxbox ~]$ type cp
cp is /bin/cp
```

我们看到这三个不同命令的检测结果。注意，ls 命令（在 Fedora 系统中）的检查结果，ls 命令实际上 是 ls 命令加上选项"--color=tty"的别名。现在我们知道为什么 ls 的输出结果是有颜色的！

### which－ 显示一个可执行程序的位置(只能找到bin目录下的命令）

```
[me@linuxbox ~]$ which cd
/usr/bin/which: no cd in
(/opt/jre1.6.0_03/bin:/usr/lib/qt-3.3/bin:/usr/kerberos/bin:/opt/jre1
.6.0_03/bin:/usr/lib/ccache:/usr/local/bin:/usr/bin:/bin:/home/me/bin)

```


### help－ 得到 shell 内部命令的帮助文档

```
[me@linuxbox ~]$ help cd
cd: cd [-L|-P] [dir]
Change ...

```

### command --help

```
[me@linuxbox ~]$ mkdir --help
Usage: mkdir [OPTION] DIRECTORY...
Create ...
```

### man－ 显示程序手册页

```
[me@linuxbox ~]$ man ls

```

### apropos－ 显示适当的命

基于某个关键字的匹配项。虽然很粗糙但有时很有用。 下面是一个以"floppy"为关键词来搜索参考手册的例子：

```
[me@linuxbox ~]$ apropos floppy
create_floppy_devices (8) - udev callout to create all possible
...

```
### whatis－ 显示非常简洁的命令说明

### info－ 显示程序 Info 条目

## 4、用别名创建自己的命令以及如何删除别名

```
alias name='string'
```

在命令"alias"之后，输入“name”，紧接着（没有空格）是一个等号，等号之后是 一串用引号引起的字符串，字符串的内容要赋值给 name。我们定义了别名之后， 这个命令别名可以使用在任何地方。

```
[me@linuxbox ~]$ alias foo='cd /usr; ls; cd -'

```

```
[me@linuxbox ~]$ alias 3ks='echo hello world'

```

删除别名：

```
[me@linuxbox ~]$ unalias foo
[me@linuxbox ~]$ type foo
bash: type: foo: not found

```





# 五、文件和目录及操作

## 1、Linux目录结构

类似于 Windows，一个“类 Unix” 的操作系统，比如说 Linux，以分层目录结构来组织所有文件。 这就意味着
所有文件组成了一棵树型目录（有时候在其它系统中叫做文件夹）， 这个目录树可能包含文件和其它的目录。文
件系统中的第一级目录称为根目录。 根目录包含文件和子目录，子目录包含更多的文件和子目录，依此类推。

![](./assets/linux_4.png)

树状目录结构

![](./assets/linux_3.png)

* **/** 根目录，万物起源。

* **/bin** bin是Binary的缩写, 包含系统启动和运行所必须的二进制程序。

* **/boot** 包含 Linux 内核，最初的 RMA 磁盘映像（系统启动时，由驱动程序所需），和启动加载程序。

* **/dev** dev是Device(设备)的缩写, 存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。

* **/etc**  这个目录用来存放所有的系统管理所需要的配置文件和子目录。

* **/home** 用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。 普通用户登录后，处于/home/用户名；root用户登录后，处于/root目录下；

* **/lib** 这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。

* **/lost+found** 这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。

* **/media：** linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。

* **/mnt** 系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了。

* **/opt** 用来安装“可选的”软件。这个主要用来存储可能 安装在系统中的商业软件产品。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。

* **/proc**  这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。

* **/root** 该目录为系统管理员，也称作超级权限者的用户主目录。

* **/run** 是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。

* **/sbin** s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。

* **/srv** 该目录存放一些服务启动之后需要提取的数据。

* **/sys** 这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统sysfs 。

* **/tmp** 这个目录是用来存放一些临时文件的。

* **/usr** 这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。

* **/usr/bin** 系统用户使用的应用程序。

* **/usr/sbin** 超级用户使用的比较高级的管理程序和系统守护程序。

* **/usr/src** 内核源代码默认的放置目录。

* **/var** 这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。

用户可以使用的目录：

* home 用户目录，

* root 系统管理员可以使用的目录

* tmp 临时文件目录

* usr 用户可以使用的目录，我们安装的软件一般在usr/local/bin目录下

* opt 安装额外软件的目录

* var 扩充目录

## 文件系统中跳转命令

### pwd — 打印出当前工作目录名（print working directory）

用法：

```
# pwd
/root/test           #输出结果
```

### cd — 更改目录 change directory 命令用于切换当前工作目录

其中 dirName 表示法可为绝对路径或相对路径。若目录名称省略，则变换至使用者的 home 目录 (也就是刚 login 时所在的目录)。

另外，~ 也表示为 home 目录 的意思， . 则是表示目前所在的目录， .. 则表示目前目录位置的上一层目录。

语法

```
cd [dirName]
dirName：要切换的目标目录。
```

实例:

```
跳到 /usr/bin/ :
cd /usr/bin

跳到自己的 home 目录 :
cd ~

跳到目前目录的上上两层 :
cd ../..

```

## 文件系统中查看命令

### ls — 列出目录内容 (list files)


语法：

```
 ls [-alrtAFR] [name...]
```

参数 :

```
-a 显示所有文件及目录 (. 开头的隐藏文件也会列出)

-l 除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出

-r 将文件以相反次序显示(原定依英文字母次序)

-t 将文件依建立时间之先后次序列出

-A 同 -a ，但不列出 "." (目前目录) 及 ".." (父目录)

-F 在列出的文件名称后加一符号；例如可执行档则加 "*", 目录则加 "/"

-R 若目录下有文件，则以下之文件亦皆依序列出

```

用法：

```
ls -ltr s*
将 /bin 目录以下所有目录及文件详细资料列出 :

ls -lR /bin
列出目前工作目录下所有文件及目录；目录于名称后加 "/", 可执行档于名称后加 "*" :

ls -AF
```

### file --列出目录内容

格式：

```
file filename
```

当调用 file 命令后，file 命令会打印出文件内容的简单描述。例如：

```
[me@linuxbox ~]$ file picture.jpg
picture.jpg: JPEG image data, JFIF standard 1.01
```

### less --浏览文件内容

格式：

```
less filename
```

例如：

```
[me@linuxbox ~]$ less /etc/passwd
```

如果文件内容多于一页，那么我们可以上下滚动文件。按下“q”键， 退出 less 程序。


## 操作文件和目录的命令

### cp — 复制文件和目录

cp 命令，复制文件或者目录。它有两种使用方法：

```
cp item1 item2
复制单个文件或目录"item1"到文件或目录"item2"，
```

```
cp item... directory
复制多个项目（文件或目录）到一个目录下。
```

```
-a, --archive 复制文件和目录，以及它们的属性，包括所有权和权限。 通常，复本具有用户所操作文件的默认属性。

-i, --interactive 在重写已存在文件之前，提示用户确认。如果这个选项不指定， cp 命令会默认重写文件。

-r, --recursive 递归地复制目录及目录中的内容。当复制目录时， 需要这个选项（或者-a 选项）。

-u, --update 当把文件从一个目录复制到另一个目录时，仅复制 目标目录中不存在的文件，或者是文件内容新于目标目录中已经存在的文件。

-v, --verbose 显示翔实的命令操作信息
```

### mv — 移动/重命名文件和目录

mv 命令可以执行文件移动和文件命名任务，这依赖于你怎样使用它。任何一种 情况下，完成操作之后，原来的
文件名不再存在。mv 使用方法与 cp 很相像：

```
mv item1 item2
把文件或目录 “item1” 移动或重命名为 “item2”, 或者：
```

```
mv item... directory
把一个或多个条目从一个目录移动到另一个目录中。
```

```
-i --interactive 在重写一个已经存在的文件之前，提示用户确认信息。 如果不指定这个选项，mv命令会默认重写文件内容。

-u --update 当把文件从一个目录移动另一个目录时，只是移动不存在的文件， 或者文件内容新于目标目录相对应文件的内容。

-v --verbose 当操作 mv 命令时，显示翔实的操作信息。
```

mv 实例

```
mv file1 file2 移动 file1 到 file2。如果 file2 存在，它的内容会被 file1 的内容重写。 如果 file2 不存在，则创建 file2。 每种情况下，file1 不再存在。

mv -i file1 file2 除了如果 file2 存在的话，在 file2 被重写之前，用户会得到 提示信息外，这个和上面的选项一样。

mv file1 file2 dir1 移动 file1 和 file2 到目录 dir1 中。dir1 必须已经存在。

mv dir1 dir2 如果目录 dir2 不存在，创建目录 dir2，并且移动目录 dir1 的内容到 目录 dir2中，同时删除目录 dir1。如果目录 dir2 存在，移动目录 dir1（及它的内容）到目录dir2。
```

### mkdir — 创建目录

格式：

```
mkdir directory...
```

注意表示法: 在描述一个命令时（如上所示），当有三个圆点跟在一个命令的参数后面， 这意味着那个参数可以重复，就像这样：

实例：

```
mkdir dir1
会创建一个名为"dir1"的目录，而
mkdir dir1 dir2 dir3
会创建三个目录，名为 dir1, dir2, dir3。
```

### rm — 删除文件和目录

```
rm item...
"item"代表一个或多个文件或目录。
```

```
-i, --interactive 在删除已存在的文件前，提示用户确认信息。 如果不指定这个选项，rm 会默默地删除文件

-r, --recursive 递归地删除文件，这意味着，如果要删除一个目录，而此目录 又包含子目录，那么子目录也会被删除。要删除一个目录，必须指定这个选项。

-f, --force 忽视不存在的文件，不显示提示信息。这选项颠覆了“--interactive”选项。

-v, --verbose 在执行 rm 命令时，显示翔实的操作信息。
```

```
rm file1 默默地删除文件

rm -i file1 除了在删除文件之前，提示用户确认信息之外，和上面的命令作用一样。

rm -r file1 dir1 删除文件 file1, 目录 dir1，及 dir1 中的内容。

rm -rf file1 dir1 同上，除了如果文件 file1，或目录 dir1 不存在的话，rm 仍会继续执行。

```

小贴士

>无论什么时候，rm 命令用到通配符（除了仔细检查输入的内容外！）， 用 ls 命令来测试通配符。这会让你看到要删除的文件列表。然后按下上箭头按键，重新调用 刚刚执行的命令，用 rm 替换 ls。

## 重定向命令

I/O 重定向 "I/O"代表输入/输出， 通过这个工具，你可以重定向命令的输入输出，命令的输入来自文件，而输出也存到文件。 也可把多个命令连接起来组成一个强大的命令管道。

与 Unix 主题“任何东西都是一个文件”保持一致，程序，比方说 ls，实际上把他们的运行结果 输送到一个叫做标准输出的特殊文件（经常用 stdout 表示），而它们的状态信息则送到另一个 叫做标准错误的文件（stderr）。默认情况下，标准输出和标准错误都连接到屏幕，而不是 保存到磁盘文件。除此之外，许多程序从一个叫做标准输入（stdin）的设备得到输入，默认情况下， 标准输入连接到键盘。

I/O 重定向允许我们可以更改输出走向和输入来向。一般地，输出送到屏幕，输入来自键盘， 但是通过 I/O 重定向，我们可以改变输入输出方向。

### 重定向标准输出--- ">" 重定向符

I/O 重定向允许我们来重定义标准输出送到哪里。重定向标准输出到另一个文件除了屏幕，我们使用 ">" 重定向符，其后跟着文件名。为什么我们要这样做呢？因为有时候把一个命令的运行结果存储到 一个文件很有用处。例如，我们可以告诉 shell 把 ls 命令的运行结果输送到文件 ls-output.txt 中去， 由文件代替屏幕。

```
[me@linuxbox ~]$ ls -l /usr/bin > ls-output.txt

```
>简单地使用重定向符，没有命令在它之前，这会删除一个已存在文件的内容或是 创建一个新的空文件。

### 追加重定向标准输出--- ">>" 重定向符

使用方法同上，只是将标准输出内容追加到了文件中。

### 重定向错误输出---

重定向标准错误缺乏专用的重定向操作符。

重定向标准错误，我们必须参考它的文件描述符。 一个程序可以在几个编号的文件流中的任一个上产生输出。然而我们必须把这些文件流的前三个看作标准输入，输出和错误，shell内部参考它们为文件描述符0，1和2，各自地。shell 提供一种表示法来重定向文件---使用文件描述符。

因为标准错误和文件描述符2一样，我们用这种 表示法来重定向标准错误：

```
[me@linuxbox ~]$ ls -l /bin/usr 2> ls-error.txt
```

`文件描述符"2"，紧挨着放在重定向操作符之前，来执行重定向标准错误到文件 ls-error.txt 任务。`

### 重定向标准输出和错误输出到同一个文件

可能有这种情况，我们希望捕捉一个命令的所有输出到一个文件。为了完成这个，我们 必须同时重定向标准输出和标准错误。有两种方法来完成任务。

第一个，传统的方法， 在旧版本 shell 中也有效：

```
[me@linuxbox ~]$ ls -l /bin/usr > ls-output.txt 2>&1
```


使用这种方法，我们完成两个重定向。首先重定向标准输出到文件 ls-output.txt，然后 重定向文件描述符2（标准错误）到文件描述符1（标准输出）使用表示法2>&1。

注意重定向的顺序安排非常重要。标准错误的重定向必须总是出现在标准输出 重定向之后，要不然它不起作用。上面的例子

```
>ls-output.txt 2>&1
```


重定向标准错误到文件 ls-output.txt，但是如果命令顺序改为：

```
2>&1 >ls-output.txt
```

则标准错误定向到屏幕。

现在的 bash 版本提供了第二种方法，更精简合理的方法来执行这种联合的重定向。

```
[me@linuxbox ~]$ ls -l /bin/usr &> ls-output.txt
```

在这个例子里面，我们使用单单一个表示法 &> 来重定向标准输出和错误到文件 ls-output.txt。




### cat － 读取一个或多个文件，然后复制它们到标准输出

格式：

```
cat [file]

```

cat 经常被用来显示简短的文本文件。

因为 cat 可以 接受不只一个文件作为参数，所以它也可以用来把文件连接在一起。比方说我们下载了一个大型文件，这个文件被分离成多个部分（USENET 中的多媒体文件经常以这种方式分离），我们想把它们连起来。
我们能用这个命令把它们连接起来：

```
cat movie.mpeg.0* > movie.mpeg
```

* 不带参数的cat命令，等待键盘输入，并输出到屏幕终端。

输入cat，然后输入任意字符，回车或ctrl+d，告诉cat到达了文件的尾部，则cat命令会将输入重复输出到终端。

### 利用cat命令和重定向符号>创建新文件

格式：

```
cat >test.txt

```

### 管道操作符|（竖杠）将前一个命令的标准输出作为后一个命令的标准输入

格式：

```
command1 | command2
```

例子：

```
[me@linuxbox ~]$ ls -l /usr/bin | less
```
使用这项技术，我们可以方便地检测会产生标准输出的任一命令的运行结果。


管道线经常用来对数据完成复杂的操作。有可能会把几个命令放在一起组成一个管道线。 通常，以这种方式使用的命令被称为过滤器。过滤器接受输入，以某种方式改变它，然后 输出它。第一个我们想试验的过滤器是sort。想象一下，我们想把目录/bin 和/usr/bin 中 的可执行程序都联合在一起，再把它们排序，然后浏览执行结果：

```
[me@linuxbox ~]$ ls /bin /usr/bin | sort | less
```

因为我们指定了两个目录（/bin 和/usr/bin），ls 命令的输出结果由有序列表组成， 各自针对一个目录。通过在管道线中包含 sort，我们改变输出数据，从而产生一个 有序列表。

### sort － 排序文本行

用来对命令输出排序

### uniq － 报道或省略重复行

命令的输出结果中，来删除任何重复行。如果我们想看到 重复的数据列表，让 uniq 命令带上"-d"选项

### grep － 打印匹配行

用来找到文件中的匹配文本。

格式：

```
grep pattern [file...]
```
当 grep 遇到一个文件中的匹配"模式"，它会打印出包含这个类型的行。grep 能够匹配的模式可以 很复杂，但是现在我们把注意力集中在简单文本匹配上面。后面我们将会研究高级模式，叫做正则表达式。


### wc － （word count）打印文件中换行符，字，和字节个数

wc（字计数）命令是用来显示文件所包含的行，字和字节数。例如：


### head － 输出文件第一部分

默认打印文件的前10行

格式：

```
head -n 5 filename
```

### tail - 输出文件最后一部分

默认打印文件的前10行

格式：

```
tail -n 5 filename
```

### tee － 从 Stdin 读取数据，并同时输出到 Stdout 和文件

为了和我们的管道隐喻保持一致，Linux 提供了一个叫做 tee 的命令，这个命令制造了 一个"tee"，安装到我们的管道上。tee 程序从标准输入读入数据，并且同时复制数据 到标准输出（允许数据继续随着管道线流动）和一个或多个文件。当在某个中间处理 阶段来捕捉一个管道线的内容时，这很有帮助。这里，我们重复执行一个先前的例子， 这次包含 tee 命令，在 grep 过滤管道线的内容之前，来捕捉整个目录列表到文件 ls.txt：

```
[me@linuxbox ~]$ ls /usr/bin | tee ls.txt | grep zip
bunzip2
bzip2
....
```
## echo命令和参数展开

### echo -字符展开：将传递到echo的任何参数在屏幕上展开

格式：

```
echo text
```
### echo * -路径名展开 展开当前工作目录下的文件名

```
[me@linuxbox ~]$ echo *
Desktop Documents ls-output.txt Music Pictures Public Templates Video

```

### echo ~ 波浪线展开 展开指定的home目录

```

[me@linuxbox ~]$ echo ~
/home/me

```

### echo $((expression)) 算数表达式展开

```
[me@linuxbox ~]$ echo $((2 + 2))

4

```

### echo 花括号展开

花括号展开模式可能包含一个开头部分叫做报头，一个结尾部分叫做附言。花括号表达式本身可 能包含一个由逗号分开的字符串列表，或者一系列整数，或者单个的字符串。这种模式不能 嵌入空白字符。这个例题使用了一系列整数：

```
[me@linuxbox ~]$ echo Front-{A,B,C}-Back
Front-A-Back Front-B-Back Front-C-Back

[me@linuxbox ~]$ echo Number_{1..5}
Number_1 Number_2 Number_3 Number_4 Number_5

[me@linuxbox ~]$ echo {Z..A}
Z Y X W V U T S R Q P O N M L K J I H G F E D C B A
```

### ehco 参数展开

```
me@linuxbox ~]$ echo $USER
me

echo this is $10000
this is 0000
```

### 双引号、单引号和转义字符

我们将要看一下引用的第一种类型，双引号。如果你把文本放在双引号中， shell 使用的特殊字符，除了 $，\ (反斜杠），和 `（倒引号）之外， 则失去它们的特殊含义，被当作普通字符来看待。这意味着单词分割，路径名展开， 波浪线展开，和花括号展开都被禁止，然而参数展开，算术展开，和命令替换 仍然执行。使用双引号，我们可以处理包含空格的文件名。比方说我们是不幸的 名为 two words.txt 文件的受害者。如果我们试图在命令行中使用这个 文件，单词分割机制会导致这个文件名被看作两个独自的参数，而不是所期望 的单个参数。


有时候我们只想引用单个字符。我们可以在字符之前加上一个反斜杠，在这个上下文中叫做转义字符。 经常在双引号中使用转义字符，来有选择地阻止展开。






# 五、进程及操作

# 六、网络及操作

# 七、编写shell程序








